{% extends 'base.html' %}
{% load static %}
{% block head %}
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <style>
    #canvas {
         background-image: url("{{ image.image_thumbnail.url }}");
         background-position: center;
         background-repeat: no-repeat;
         background-size: contain;
     }
     h1{
           text-align: center;
     }
  </style>
  <title>Document</title>
{% endblock %}
{% block containerbody %}
  <h1 class="retro">박스!!</h1>
  <div style="display: inline-block;">
    <canvas id="canvas" width="800" height="600">
        이 브라우저는 캔버스를 지원하지 않습니다.
    </canvas>
    <div style="float: right; width: 250px; height: 400px; margin-left: 40px;">
      <div class="row" style="width: 300px;">
            <label for="selcolor">색상 : </label>
            <select id="selcolor" style="width: 50%; height: 50px; margin-top: 50px;">
            <option value="rgba(255,255,0,0.6)">노랑</option>
            <option value="rgba(255,0,0,0.3)">빨강</option>
            <option value="rgb(0,255,0)">초록</option>
            <option value="rgba(0,0,255,0.5)">파랑</option>
            </select>
      </div>
      <div  style="width: 80%; display: inline-block; margin-top: 90px;">
            <div style="width: 50px; height: 80px; background-color: rgb(238, 245, 142); float: left;border-radius: 30px 0px 0px 30px;"></div>
            <div style=" float: left;"><input class="retro" type="button" id="clearone" value="지우개" style="width: auto; height: 80px; font-size: 40pt;"/></div>   
      </div>
      <div>
        <form action="" method="POST" id="submit">
            {% csrf_token %}
            <input class="retro" id="btnfinish" type="submit" value="ㄱㄱ" style="width: 80%; height: 80px; font-size: 40pt; margin-top: 90px;">
        </form>
      </div>
  </div>
</div>
  
<script>

  var canvas;
  var ctx;
  var arRectangle = new Array();
  var sx, sy;                  // 드래그 시작점
  var ex, ey;                  // 드래그 끝점
  var color;               // 현재 색상
  var drawing;                // 그리고 있는 중인가
  var moving = -1;              // 이동중인 도형 첨자
  var arrPosition = new Array();
  // 사각형 생성자
  function Rectangle(sx, sy, ex, ey, color) {
        this.sx = sx;
        this.sy = sy;
        this.ex = ex;
        this.ey = ey;
        this.color = color;
  }
  // x, y 위치의 사각형 찾음. 없으면 -1
  function getRectangle(x, y) {
        for (var i = 0;i < arRectangle.length;i++) {
            var rect = arRectangle[i];
            if (x > rect.sx && x < rect.ex && y > rect.sy && y < rect.ey) {
                  return i;
            }
        }
        return -1;
  }



  // 화면 지우고 모든 도형을 순서대로 다 그림
  function drawRects() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (var i = 0;i < arRectangle.length;i++) {
            var r = arRectangle[i];
            ctx.fillStyle = r.color;
            ctx.fillRect(r.sx, r.sy, r.ex-r.sx, r.ey-r.sy);
            ctx.strokeRect(r.sx, r.sy, r.ex-r.sx, r.ey-r.sy);
        }
  }
  window.onload = function() {
        canvas = document.getElementById("canvas");
        if (canvas == null || canvas.getContext == null) return;
        ctx = canvas.getContext("2d");
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        color = "rgba(255, 255, 0, 0.5)"
        ctx.fillStyle = color;
        

        canvas.onmousedown = function(e) {
            e.preventDefault();

            

            // 클릭한 좌표 구하고 그 위치에 도형이 있는지 조사
            sx = canvasX(e.clientX);
            sy = canvasY(e.clientY);
            //moving = getRectangle(sx, sy);

            // 도형을 클릭한 것이 아니면 그리기 시작

            if (moving == -1) {
                  drawing = true;
            }

        }

      

        canvas.onmousemove = function(e) {
            e.preventDefault();
            ex = canvasX(e.clientX);
            ey = canvasY(e.clientY);

            // 화면 다시 그리고 현재 도형 그림

            if (drawing) {
                  drawRects();
                  ctx.fillStyle = color;
                  ctx.fillRect(sx, sy, ex-sx, ey-sy);
                  ctx.strokeRect(sx, sy, ex-sx, ey-sy);
            }

            

            // 상대적인 마우스 이동 거리만큼 도형 이동

            // if (moving != -1) {
            //       var r = arRectangle[moving];
            //       r.sx += (ex - sx);
            //       r.sy += (ey - sy);
            //       r.ex += (ex - sx);
            //       r.ey += (ey - sy);
            //       sx = ex;
            //       sy = ey;
            //       drawRects();
            // }

        }

      

        canvas.onmouseup = function(e) {

            // 좌표 정규화해서 새로운 도형을 배열에 추가

            if (drawing) {
                  var x1 = Math.min(sx, ex);
                  var y1 = Math.min(sy, ey);
                  var x2 = Math.max(sx, ex);
                  var y2 = Math.max(sy, ey);
                  arRectangle.push(new Rectangle(x1, y1, x2, y2,color));
                  arrPosition.push(x1+'/'+y1 +'/'+x2+'/'+y2);
            }
            drawing = false;
            moving = -1;

        }            

  }



  var selcolor = document.getElementById("selcolor");
  selcolor.onchange = function(e) {
        color = selcolor.value;
  }



  // var btnclear = document.getElementById("clear");
  // btnclear.onclick = function(e) {
  //       ctx.clearRect(0, 0, canvas.width, canvas.height);
  //       arRectangle.length = 0;
  // }

  var btnclearone = document.getElementById("clearone");

  btnclearone.onclick = function(e) {

        arRectangle.pop();
        arrPosition.pop();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawRects();
        document.querySelector("#Plist").lastChild.remove()

  }

  var btnfinish = document.getElementById("btnfinish");

  btnfinish.onclick = function(e) {

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        arRectangle.length = 0;
      //   arrPosition.length = 0;

  }



  function canvasX(clientX) {

        var bound = canvas.getBoundingClientRect();
        var bw = 5;
        return (clientX - bound.left - bw) * (canvas.width / (bound.width - bw * 2));
  }



  function canvasY(clientY) {

        var bound = canvas.getBoundingClientRect();
        var bw = 5;
        return (clientY - bound.top - bw) * (canvas.height / (bound.height - bw * 2));

  }

  document.querySelector('#submit').addEventListener('submit', function(event) {
        event.preventDefault()
        console.log(arrPosition)
        const data = new FormData()
        data.append('position', arrPosition)
        console.log(data)
        axios.defaults.xsrfCookieName = 'csrftoken';
        axios.defaults.xsrfHeaderName = 'X-CSRFToken';
        axios.post('/boxing/save_position/{{ image.pk }}/', data)
            .then(data => {
                  console.log(data)
            })
  })
  </script>
{% endblock %}