{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <style>
    #canvas {
         border:5px solid magenta;
         background-image: url("{{ image.image_thumbnail.url }}");
         background-position: center;
         background-repeat: no-repeat;
         background-size: contain;
     }
  </style>
  <title>Document</title>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

</head>
<body>
  <h1>태그 안된 곳</h1>
  <div style="display: inline-block;">
    <canvas id="canvas" width="800" height="600">
        이 브라우저는 캔버스를 지원하지 않습니다.
    </canvas>
    <div style="float: right;">
      색상 : <select id="selcolor">
          <option value="rgba(255,255,0,0.6)">노랑</option>
          <option value="rgba(255,0,0,0.3)">빨강</option>
          <option value="rgb(0,255,0)">초록</option>
          <option value="rgba(0,0,255,0.5)">파랑</option>
      </select>
      <!-- <input type="button" id="clear" value="모두 지움"/> -->
      <input type="button" id="clearone" value="마지막 지움"/>
      <div id="Plist">
        <p>좌표 리스트</p>
        <form action="" method="POST" id="submit">
            {% csrf_token %}
            <!-- <input type="hidden" name="position" value="arrPosition"> -->
            <input id="btnfinish" type="submit" value="제출">
        </form>
      </div>
  </div>
</div>
  
<script>

  var canvas;
  var ctx;
  var arRectangle = new Array();
  var sx, sy;                  // 드래그 시작점
  var ex, ey;                  // 드래그 끝점
  var color;               // 현재 색상
  var drawing;                // 그리고 있는 중인가
  var moving = -1;              // 이동중인 도형 첨자
  var arrPosition = new Array();
  // 사각형 생성자
  function Rectangle(sx, sy, ex, ey, color) {
        this.sx = sx;
        this.sy = sy;
        this.ex = ex;
        this.ey = ey;
        this.color = color;
  }
  // x, y 위치의 사각형 찾음. 없으면 -1
  function getRectangle(x, y) {
        for (var i = 0;i < arRectangle.length;i++) {
            var rect = arRectangle[i];
            if (x > rect.sx && x < rect.ex && y > rect.sy && y < rect.ey) {
                  return i;
            }
        }
        return -1;
  }



  // 화면 지우고 모든 도형을 순서대로 다 그림
  function drawRects() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (var i = 0;i < arRectangle.length;i++) {
            var r = arRectangle[i];
            ctx.fillStyle = r.color;
            ctx.fillRect(r.sx, r.sy, r.ex-r.sx, r.ey-r.sy);
            ctx.strokeRect(r.sx, r.sy, r.ex-r.sx, r.ey-r.sy);
        }
  }
  window.onload = function() {
        canvas = document.getElementById("canvas");
        if (canvas == null || canvas.getContext == null) return;
        ctx = canvas.getContext("2d");
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        color = "rgba(255, 255, 0, 0.5)"
        ctx.fillStyle = color;
      //   var img = new Image();
      //   img.src = "{{ image.image_thumbnail.url }}"
        
      //   ctx.drawImage(img,0,0);
        

        canvas.onmousedown = function(e) {
            e.preventDefault();

            

            // 클릭한 좌표 구하고 그 위치에 도형이 있는지 조사
            sx = canvasX(e.clientX);
            sy = canvasY(e.clientY);
            //moving = getRectangle(sx, sy);

            // 도형을 클릭한 것이 아니면 그리기 시작

            if (moving == -1) {
                  drawing = true;
            }

        }

      

        canvas.onmousemove = function(e) {
            e.preventDefault();
            ex = canvasX(e.clientX);
            ey = canvasY(e.clientY);

            // 화면 다시 그리고 현재 도형 그림

            if (drawing) {
                  drawRects();
                  ctx.fillStyle = color;
                  ctx.fillRect(sx, sy, ex-sx, ey-sy);
                  ctx.strokeRect(sx, sy, ex-sx, ey-sy);
            }

            

            // 상대적인 마우스 이동 거리만큼 도형 이동

            // if (moving != -1) {
            //       var r = arRectangle[moving];
            //       r.sx += (ex - sx);
            //       r.sy += (ey - sy);
            //       r.ex += (ex - sx);
            //       r.ey += (ey - sy);
            //       sx = ex;
            //       sy = ey;
            //       drawRects();
            // }

        }

      

        canvas.onmouseup = function(e) {

            // 좌표 정규화해서 새로운 도형을 배열에 추가

            if (drawing) {
                  var x1 = Math.min(sx, ex);
                  var y1 = Math.min(sy, ey);
                  var x2 = Math.max(sx, ex);
                  var y2 = Math.max(sy, ey);
                  arRectangle.push(new Rectangle(x1, y1, x2, y2,color));
                  arrPosition.push(x1+'/'+y1 +'/'+x2+'/'+y2);
            }
            drawing = false;
            moving = -1;
            
              const pTag = document.createElement('p')
              pTag.innerText = arrPosition[arrPosition.length-1]
              const Plist = document.querySelector('#Plist')
              Plist.append(pTag)
            //   axios.post('/boxing/{{image.pk}}/')
            //       .then(data => {
            //             console.log(data)
            //       })
              // for(i=0; i<arrPosition.length; i++){
              //     alert(arrPosition[i]);
              // }

        }            

  }



  var selcolor = document.getElementById("selcolor");
  selcolor.onchange = function(e) {
        color = selcolor.value;
  }



  // var btnclear = document.getElementById("clear");
  // btnclear.onclick = function(e) {
  //       ctx.clearRect(0, 0, canvas.width, canvas.height);
  //       arRectangle.length = 0;
  // }

  var btnclearone = document.getElementById("clearone");

  btnclearone.onclick = function(e) {

        arRectangle.pop();
        arrPosition.pop();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawRects();
        document.querySelector("#Plist").lastChild.remove()

  }

  var btnfinish = document.getElementById("btnfinish");

  btnfinish.onclick = function(e) {

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        arRectangle.length = 0;
      //   arrPosition.length = 0;

  }



  function canvasX(clientX) {

        var bound = canvas.getBoundingClientRect();
        var bw = 5;
        return (clientX - bound.left - bw) * (canvas.width / (bound.width - bw * 2));
  }



  function canvasY(clientY) {

        var bound = canvas.getBoundingClientRect();
        var bw = 5;
        return (clientY - bound.top - bw) * (canvas.height / (bound.height - bw * 2));

  }

  document.querySelector('#submit').addEventListener('submit', function(event) {
        event.preventDefault()
        console.log(arrPosition)
        const data = new FormData()
        data.append('position', arrPosition)
        console.log(data)
        axios.defaults.xsrfCookieName = 'csrftoken';
        axios.defaults.xsrfHeaderName = 'X-CSRFToken';
        axios.post('/boxing/save_position/{{ image.pk }}/', data)
            .then(data => {
                  console.log(data)
            })
  })
  </script>
</body>
</html>